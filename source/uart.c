/******************************************************************************
文 件 名   : uart.c

@file uart.c
@brief at89c51串口驱动
******************************************************************************/

/*----------------------------------------------*
 * 包含头文件                                   *
 *----------------------------------------------*/
#include "main.h"

#ifdef UART_DEV_DRIVER

/*----------------------------------------------*
 * 宏定义                                 *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 枚举定义                            *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 结构体定义                              *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 外部函数原型说明                                     *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 内部函数原型说明                                   *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 全局变量                                     *
 *----------------------------------------------*/

/*----------------------------------------------*
 * 常量定义                                       *
 *----------------------------------------------*/


/*---------------------------------------------------------------------------*/
/**
*@brief at89c51串口初始化
*
*
*@param none
*
*@return 
* 
*
*@note 外部晶振11.05926MHz, 波特率9600
*
*/
void uart_init(void)
{
  SCON = 0x50;    ///<8位数据,可变波特率
  TMOD &= 0x0f;   ///<设定定时器1为8位自动重装方式
  TMOD |= 0x20;   ///<设定定时器1为8位自动重装方式
  PCON = 0x00;    ///<波特率不加倍
  TH1 = 0xFD;     ///<设定定时初值
  TL1 = 0xFD;     ///<设定定时初值
  TR1 = 1;        ///<启动定时器1
  REN = 1;        ///<使能接收
  ES = 1;         ///<打开串口中断
}
/*---------------------------------------------------------------------------*/
/**
*@brief 串口阻塞发送一个字符
*
*
*@param ch 要发送的字符
*
*@return 
* 
*
*@note 
*
*/
void uart_put_char(uint8_t ch)
{
  ES = 0;           ///<关闭串口中断
  TI = 0;           ///<清除中断标志
  SBUF = ch;        ///<写入数据
  while (TI == 0){} ///<等待发送完成
  TI = 0;           ///<清除中断标志
  ES = 1;           ///<打开串口中断
}
/*---------------------------------------------------------------------------*/
/**
*@brief 串口阻塞发送数据
*
*
*@param buf 要发送的字符数组地址
*@param len 要发送的数据长度
*
*@return 
* 
*
*@note 
*
*/
void uart_block_send(uint8_t * buf, uint16_t len)
{
  uint16_t i;
  
  ES = 0;  ///<关闭串口中断
  TI = 0;  ///<清除中断标志
  
  for(i = 0; i < len; i++){
    SBUF = buf[i]; ///<写入数据
    while (TI == 0){} ///<等待发送完成
    TI = 0;           ///<清除中断标志
  }
  ES = 1;             ///<打开串口中断
}
/*---------------------------------------------------------------------------*/
/**
*@brief 串口阻塞接收数据
*
*
*@param pData : 接收数据缓存
*@param Size : 接收数据长度
*@param Timeout : 超时时间ms
*
*@return 接收到的字符长度
* 
*
*@note 
*
*/
uint16_t uart_block_receive(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  uint32_t tickstart;
  uint16_t len = 0;

  if(pData == NULL){
    return 0;
  }
  
  ES = 0;///<关闭串口中断
  RI = 0;///<清除标志
  
  tickstart = HAL_GetTick();

  while(len < Size){

    if(RI){///<接收数据标志
  		RI = 0;///<清除标志
  		pData[len] = SBUF;
      ++len;
  	}
    if((uint32_t)(HAL_GetTick() - tickstart) > Timeout){
      break;
    }
    
  }

  RI = 0;///<清除标志
  ES = 1;///<打开串口中断
  
  return len;
}
/*---------------------------------------------------------------------------*/
/**
*@brief 发送一串字符串
*
*
*@param puts 要发送的字符串
*
*@return 
* 
*
*@note 
*
*/
void print_string(uint8_t code *puts)
{
  for (; *puts != 0;	puts++){///<遇到停止符0结束
    uart_put_char(*puts);
  }
}
/*---------------------------------------------------------------------------*/
/**
*@brief 重定向printf
*
*
*@param c 要发送的字符
*
*@return 0
* 
*
*@note 
*
*/
char putchar(char c)
{        
  //uart_put_char((uint8_t)c);///<串口阻塞发送一个字符
  soft_serial_putchar((const uint8_t)c);
  return 0;
}
/*---------------------------------------------------------------------------*/
/**
*@brief 串口中断入口
*
*
*@param none
*
*@return 
* 
*
*@note 
*
*/
void uart_interrupt() interrupt 4
{  
  if(RI)///<接收数据标志
	{
		RI = 0;///<清除标志
		esp8266_uart_rec_irq(SBUF);
	}

	if(TI) ///<发送数据标志
	{
		TI = 0; ///<清除标志
	}
}
/*---------------------------------------------------------------------------*/

#endif  //UART_DEV_DRIVER

